import{j as w}from"./jsx-runtime.D_zvdyIk.js";import{r as A}from"./index.BVOCwoKb.js";const I=`
attribute vec2 a_position;
attribute float a_alpha;
uniform vec2 u_resolution;
uniform vec3 u_color;
varying float v_alpha;

void main() {
  vec2 clipSpace = ((a_position / u_resolution) * 2.0) - 1.0;
  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  v_alpha = a_alpha;
}
`,U=`
precision mediump float;
uniform vec3 u_color;
varying float v_alpha;

void main() {
  gl_FragColor = vec4(u_color, v_alpha);
}
`;class G{gl;program=null;staticLinesBuffer=null;gridBuffer=null;staticVertices;gridVertices;numLines;lineColor;vanishingPoint;isDisposed=!1;constructor(s,e,r,o){this.gl=s,this.numLines=e,this.lineColor=this.hexToRgb(r),this.vanishingPoint=o,this.staticVertices=new Float32Array((e+1)*4*6),this.gridVertices=new Float32Array(15*24),this.initializeWebGL()}hexToRgb(s){const e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(s);return e?[parseInt(e[1],16)/255,parseInt(e[2],16)/255,parseInt(e[3],16)/255]:[0,1,0]}createShader(s,e){const r=this.gl.createShader(s);return r?(this.gl.shaderSource(r,e),this.gl.compileShader(r),this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS)?r:(console.error("Shader compile error:",this.gl.getShaderInfoLog(r)),this.gl.deleteShader(r),null)):null}initializeWebGL(){const s=this.createShader(this.gl.VERTEX_SHADER,I),e=this.createShader(this.gl.FRAGMENT_SHADER,U);if(!(!s||!e)&&(this.program=this.gl.createProgram(),!!this.program)){if(this.gl.attachShader(this.program,s),this.gl.attachShader(this.program,e),this.gl.linkProgram(this.program),!this.gl.getProgramParameter(this.program,this.gl.LINK_STATUS)){console.error("Program link error:",this.gl.getProgramInfoLog(this.program));return}this.staticLinesBuffer=this.gl.createBuffer(),this.gridBuffer=this.gl.createBuffer(),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA)}}resize(s,e){this.gl.viewport(0,0,s,e),this.precomputeStaticLines(s,e)}precomputeStaticLines(s,e){const r=s*.1,o=e*.15,l=(s-r)/2,a=(e-o)/2;let i=0;for(let t=0;t<=this.numLines;t++){const n=t/this.numLines,c=n*s,g=0,V=c+(l+n*r-c)*this.vanishingPoint,h=g+(a-g)*this.vanishingPoint,_=1,m=0;this.staticVertices[i++]=c,this.staticVertices[i++]=g,this.staticVertices[i++]=_,this.staticVertices[i++]=V,this.staticVertices[i++]=h,this.staticVertices[i++]=m;const d=n*s,p=e,f=d+(l+n*r-d)*this.vanishingPoint,u=p+(a+o-p)*this.vanishingPoint,x=1,P=0;this.staticVertices[i++]=d,this.staticVertices[i++]=p,this.staticVertices[i++]=x,this.staticVertices[i++]=f,this.staticVertices[i++]=u,this.staticVertices[i++]=P;const L=0,R=n*e,B=L+(l-L)*this.vanishingPoint,E=R+(a+n*o-R)*this.vanishingPoint,F=1,T=0;this.staticVertices[i++]=L,this.staticVertices[i++]=R,this.staticVertices[i++]=F,this.staticVertices[i++]=B,this.staticVertices[i++]=E,this.staticVertices[i++]=T;const b=s,S=n*e,y=b+(l+r-b)*this.vanishingPoint,C=S+(a+n*o-S)*this.vanishingPoint,z=1,D=0;this.staticVertices[i++]=b,this.staticVertices[i++]=S,this.staticVertices[i++]=z,this.staticVertices[i++]=y,this.staticVertices[i++]=C,this.staticVertices[i++]=D}this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.staticLinesBuffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,this.staticVertices,this.gl.STATIC_DRAW)}render(s,e,r,o){if(!this.program||this.isDisposed)return;this.gl.clearColor(0,0,0,0),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.useProgram(this.program);const l=this.gl.getUniformLocation(this.program,"u_resolution"),a=this.gl.getUniformLocation(this.program,"u_color");this.gl.uniform2f(l,r,o),this.gl.uniform3f(a,this.lineColor[0],this.lineColor[1],this.lineColor[2]);const i=this.gl.getAttribLocation(this.program,"a_position"),t=this.gl.getAttribLocation(this.program,"a_alpha");this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.staticLinesBuffer),this.gl.enableVertexAttribArray(i),this.gl.enableVertexAttribArray(t),this.gl.vertexAttribPointer(i,2,this.gl.FLOAT,!1,12,0),this.gl.vertexAttribPointer(t,1,this.gl.FLOAT,!1,12,8),this.gl.drawArrays(this.gl.LINES,0,this.staticVertices.length/3),this.updateGridVertices(s,e,r,o),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.gridBuffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,this.gridVertices,this.gl.DYNAMIC_DRAW),this.gl.vertexAttribPointer(i,2,this.gl.FLOAT,!1,12,0),this.gl.vertexAttribPointer(t,1,this.gl.FLOAT,!1,12,8);let n=0;for(let c=0;c<this.gridVertices.length;c+=3)(this.gridVertices[c]!==0||this.gridVertices[c+1]!==0)&&n++;this.gl.drawArrays(this.gl.LINES,0,n)}updateGridVertices(s,e,r,o){const l=s*e,a=40,i=15;this.gridVertices.fill(0);let t=0;for(let n=0;n<i;n++){const g=(n*a+l)%(a*i)/(i*a);if(g>1||g<0)continue;const V=Math.pow(g,2.5),h=Math.pow(g,5),_=r*.1*this.vanishingPoint,m=o*.15*this.vanishingPoint,d=_+(r-_)*V,p=m+(o-m)*V,f=(r-d)/2,u=(o-p)/2;t+5<this.gridVertices.length&&(this.gridVertices[t++]=f,this.gridVertices[t++]=u,this.gridVertices[t++]=h,this.gridVertices[t++]=f+d,this.gridVertices[t++]=u,this.gridVertices[t++]=h),t+5<this.gridVertices.length&&(this.gridVertices[t++]=f+d,this.gridVertices[t++]=u,this.gridVertices[t++]=h,this.gridVertices[t++]=f+d,this.gridVertices[t++]=u+p,this.gridVertices[t++]=h),t+5<this.gridVertices.length&&(this.gridVertices[t++]=f+d,this.gridVertices[t++]=u+p,this.gridVertices[t++]=h,this.gridVertices[t++]=f,this.gridVertices[t++]=u+p,this.gridVertices[t++]=h),t+5<this.gridVertices.length&&(this.gridVertices[t++]=f,this.gridVertices[t++]=u+p,this.gridVertices[t++]=h,this.gridVertices[t++]=f,this.gridVertices[t++]=u,this.gridVertices[t++]=h)}}dispose(){this.isDisposed||(this.staticLinesBuffer&&(this.gl.deleteBuffer(this.staticLinesBuffer),this.staticLinesBuffer=null),this.gridBuffer&&(this.gl.deleteBuffer(this.gridBuffer),this.gridBuffer=null),this.program&&(this.gl.deleteProgram(this.program),this.program=null),this.isDisposed=!0)}}const W=({numLines:v=20,lineColor:s="#00ff00",animationSpeed:e=1,maxOpacity:r=1,vanishingPoint:o=.75})=>{const l=A.useRef(null),a=A.useRef(null),i=A.useRef(0),t=A.useRef(null),n=r;return A.useEffect(()=>{const c=l.current;if(!c)return;const g=c.getContext("webgl")||c.getContext("experimental-webgl");if(!g){console.warn("WebGL not supported, falling back to 2D canvas");return}let V,h;const _=()=>{V=c.width=window.innerWidth,h=c.height=window.innerHeight,t.current&&t.current.resize(V,h)};t.current=new G(g,v,s,o),window.addEventListener("resize",_),_();const m=()=>{t.current&&(i.current++,t.current.render(i.current,e,V,h)),a.current=requestAnimationFrame(m)};return m(),()=>{window.removeEventListener("resize",_),a.current&&cancelAnimationFrame(a.current),t.current&&(t.current.dispose(),t.current=null)}},[v,s,e,r,o]),w.jsx("canvas",{ref:l,className:"fixed inset-0 w-screen h-screen bg-transparent -z-10",style:{opacity:n}})};export{W as default};
